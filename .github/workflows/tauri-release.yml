name: Manually Triggered Desktop Release

permissions:
    contents: write
    actions: read
    releases: write
    packages: write
    security-events: write

concurrency:
    group: desktop-release-${{ github.ref }}
    cancel-in-progress: true

on:
    workflow_dispatch:
        inputs:
            version-bump:
                description: 'The type of version bump (major, minor, or patch)'
                required: true
                default: 'patch'
                type: choice
                options:
                    - patch
                    - minor
                    - major

jobs:
    version:
        runs-on: ubuntu-latest
        outputs:
            new_version: ${{ steps.bump.outputs.new_version }}
            changelog: ${{ steps.changelog.outputs.clean_changelog }}
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  token: ${{ secrets.GITHUB_TOKEN }}

            - name: Configure Git
              run: |
                  git config user.name "github-actions[bot]"
                  git config user.email "github-actions[bot]@users.noreply.github.com"

            - name: Compute New Version
              id: bump
              run: |
                  set -euo pipefail

                  LATEST_TAG=$(git tag --sort=-v:refname | head -n 1)
                  if [[ -z "$LATEST_TAG" ]]; then
                    LATEST_TAG="v0.0.0"
                  fi

                  if [[ "$LATEST_TAG" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
                    MAJOR=${BASH_REMATCH[1]}
                    MINOR=${BASH_REMATCH[2]}
                    PATCH=${BASH_REMATCH[3]}
                  else
                    echo "Could not parse latest tag: $LATEST_TAG. Starting from v0.0.0."
                    MAJOR=0; MINOR=0; PATCH=0
                  fi

                  BUMP_TYPE="${{ github.event.inputs.version-bump }}"
                  if [ "$BUMP_TYPE" == "major" ]; then
                    MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0
                  elif [ "$BUMP_TYPE" == "minor" ]; then
                    MINOR=$((MINOR + 1)); PATCH=0
                  else
                    PATCH=$((PATCH + 1))
                  fi

                  NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
                  VERSION_NO_V="$MAJOR.$MINOR.$PATCH"

                  echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
                  echo "version_no_v=$VERSION_NO_V" >> "$GITHUB_OUTPUT"
                  echo "New version will be: $NEW_VERSION"

            - name: Update Version Files
              run: |
                  VERSION_NO_V="${{ steps.bump.outputs.version_no_v }}"

                  jq --arg ver "$VERSION_NO_V" '.version = $ver' package.json > package.json.tmp
                  mv package.json.tmp package.json

                  jq --arg ver "$VERSION_NO_V" '.version = $ver' src-tauri/tauri.conf.json > src-tauri/tauri.conf.json.tmp
                  mv src-tauri/tauri.conf.json.tmp src-tauri/tauri.conf.json

                  sed -i "s/^version = \".*\"/version = \"$VERSION_NO_V\"/" src-tauri/Cargo.toml

                  echo "Updated version files to $VERSION_NO_V"

            - name: Generate Changelog
              id: changelog
              uses: TriPSs/conventional-changelog-action@v6
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  skip-on-empty: 'false'
                  skip-commit: 'true'
                  skip-version-file: 'true'
                  skip-git-pull: 'true'
                  skip-tag: 'true'
                  git-push: 'false'
                  output-file: 'false'
                  release-count: 0
                  tag-prefix: 'v'

            - name: Commit Version Bump
              run: |
                  NEW_VERSION="${{ steps.bump.outputs.new_version }}"

                  git add package.json src-tauri/tauri.conf.json src-tauri/Cargo.toml
                  git commit -m "chore: bump version to $NEW_VERSION"
                  git tag "$NEW_VERSION"
                  git push origin HEAD:${{ github.ref_name }}
                  git push origin "$NEW_VERSION"

    build-tauri:
        runs-on: ${{ matrix.os }}
        needs: version
        strategy:
            fail-fast: false
            matrix:
                os: [ubuntu-latest, windows-2022, macos-latest]

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  ref: ${{ github.ref_name }}
                  fetch-depth: 0

            - name: Pull latest changes
              run: git pull origin ${{ github.ref_name }}

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: 22

            - name: Cache Node.js Dependencies
              uses: actions/cache@v4
              with:
                  path: ~/.npm
                  key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
                  restore-keys: ${{ runner.os }}-node-

            - name: Install Dependencies
              run: npm ci
              shell: bash

            - name: Setup Rust (stable)
              uses: dtolnay/rust-toolchain@stable

            - name: Install Linux Dependencies (Ubuntu)
              if: matrix.os == 'ubuntu-latest'
              run: |
                  sudo apt update
                  sudo apt install -y libwebkit2gtk-4.1-dev \
                  build-essential \
                  curl \
                  wget \
                  file \
                  libxdo-dev \
                  libssl-dev \
                  libayatana-appindicator3-dev \
                  librsvg2-dev
              shell: bash

            - name: Install macOS Dependencies
              if: matrix.os == 'macos-latest'
              run: |
                  brew update
                  brew install pkg-config
              shell: bash

            - name: Install Windows Dependencies
              if: matrix.os == 'windows-2022'
              shell: powershell
              run: |
                  choco install -y wixtoolset nsis webview2-runtime

            - name: Cache Rust Dependencies
              uses: Swatinem/rust-cache@v2
              with:
                  workspaces: './src-tauri'

            - name: Build Tauri App
              run: |
                  set -euo pipefail
                  echo "Starting Tauri build process..."

                  if ! npm run tauri build; then
                    echo "Tauri build failed"
                    echo "Build logs:"
                    find src-tauri/target -name "*.log" -exec echo "=== {} ===" \; -exec cat {} \;
                    exit 1
                  fi

                  echo "Tauri build completed successfully"

                  if [ ! -d "src-tauri/target/release/bundle" ]; then
                    echo "Build output directory not found"
                    exit 1
                  fi

                  echo "Build artifacts:"
                  find src-tauri/target/release/bundle -type f | head -10
              shell: bash

            - name: Code Signing Setup (Windows)
              if: matrix.os == 'windows-2022' && secrets.WINDOWS_CERTIFICATE_BASE64 != ''
              shell: powershell
              run: |
                  $certBytes = [Convert]::FromBase64String("${{ secrets.WINDOWS_CERTIFICATE_BASE64 }}")
                  $certPath = "C:\temp\codesign.pfx"
                  [System.IO.File]::WriteAllBytes($certPath, $certBytes)

                  Import-PfxCertificate -FilePath $certPath -CertStoreLocation Cert:\CurrentUser\My -Password (ConvertTo-SecureString "${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}" -AsPlainText -Force)

                  echo "Windows code signing certificate imported"

            - name: Code Signing (Windows)
              if: matrix.os == 'windows-2022' && secrets.WINDOWS_CERTIFICATE_BASE64 != ''
              shell: powershell
              run: |
                  $filesToSign = Get-ChildItem -Path "src-tauri\target\release\bundle" -Recurse -Include @("*.exe", "*.msi")

                  foreach ($file in $filesToSign) {
                    & "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22000.0\x64\signtool.exe" sign `
                      /f "C:\temp\codesign.pfx" `
                      /p "${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}" `
                      /tr "http://timestamp.digicert.com" `
                      /td sha256 `
                      /fd sha256 `
                      $file.FullName
                    
                    Write-Host "Signed: $($file.FullName)"
                  }

            - name: Code Signing Setup (macOS)
              if: matrix.os == 'macos-latest' && secrets.APPLE_CERTIFICATE_BASE64 != ''
              run: |
                  echo "${{ secrets.APPLE_CERTIFICATE_BASE64 }}" | base64 --decode > /tmp/developer_certificate.p12
                  security import /tmp/developer_certificate.p12 -k ~/Library/Keychains/login.keychain-db -P "${{ secrets.APPLE_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign
                  security set-key-partition-list -S apple-tool:,apple: -s -k "${{ secrets.APPLE_CERTIFICATE_PASSWORD }}" ~/Library/Keychains/login.keychain-db
                  echo "macOS code signing certificate imported"

            - name: Code Signing (macOS)
              if: matrix.os == 'macos-latest' && secrets.APPLE_CERTIFICATE_BASE64 != ''
              run: |
                  find src-tauri/target/release/bundle -name "*.app" -exec codesign --force --deep --sign "${{ secrets.APPLE_DEVELOPER_ID }}" {} \;
                  find src-tauri/target/release/bundle -name "*.dmg" -exec codesign --force --sign "${{ secrets.APPLE_DEVELOPER_ID }}" {} \;
                  echo "macOS applications signed"

            - name: Code Signing Setup (Linux)
              if: matrix.os == 'ubuntu-latest' && secrets.LINUX_GPG_PRIVATE_KEY != ''
              run: |
                  echo "${{ secrets.LINUX_GPG_PRIVATE_KEY }}" | base64 --decode > /tmp/gpg_private.key
                  gpg --import /tmp/gpg_private.key
                  echo "Linux GPG signing key imported"

            - name: Code Signing (Linux)
              if: matrix.os == 'ubuntu-latest' && secrets.LINUX_GPG_PRIVATE_KEY != ''
              run: |
                  for file in $(find src-tauri/target/release/bundle -name "*.deb" -o -name "*.AppImage"); do
                    gpg --detach-sign --armor --local-user "${{ secrets.LINUX_GPG_KEY_ID }}" "$file"
                    echo "Signed: $file"
                  done

            - name: Upload Tauri Build Artifacts
              uses: actions/upload-artifact@v4
              with:
                  name: Tauri Build Artifacts (${{ matrix.os }})
                  path: |
                      src-tauri/target/release/bundle

    create-release:
        runs-on: ubuntu-latest
        needs: [version, build-tauri]
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  token: ${{ secrets.GITHUB_TOKEN }}
                  ref: ${{ github.ref_name }}

            - name: Configure Git
              run: |
                  git config user.name "github-actions[bot]"
                  git config user.email "github-actions[bot]@users.noreply.github.com"

            - name: Update Repository Changelog
              run: |
                  set -euo pipefail
                  CHANGELOG_FILE="CHANGELOG.md"
                  TEMP_CHANGELOG="$(mktemp)"

                  cat <<'EOF' > "$TEMP_CHANGELOG"
                  ${{ needs.version.outputs.changelog }}
                  EOF

                  if [ -f "$CHANGELOG_FILE" ]; then
                    printf "\n" >> "$TEMP_CHANGELOG"
                    cat "$CHANGELOG_FILE" >> "$TEMP_CHANGELOG"
                  mv "$TEMP_CHANGELOG" "$CHANGELOG_FILE"

            - name: Commit and Push Changelog
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  set -euo pipefail

                  git pull origin ${{ github.ref_name }} --rebase
                  if git diff --quiet -- CHANGELOG.md; then
                    echo "No changelog updates to commit."
                    exit 0
                  fi

                  git add CHANGELOG.md
                  git commit -m "chore: update changelog for ${{ needs.version.outputs.new_version }}"
                  git push origin HEAD:${{ github.ref_name }}

            - name: Download all build artifacts
              uses: actions/download-artifact@v4
              with:
                  path: artifacts

            - name: Prepare Release Assets
              run: |
                  mkdir -p release-assets
                  find artifacts -type f \( -name "*.deb" -o -name "*.AppImage" -o -name "*.msi" -o -name "*.dmg" \) -exec cp {} release-assets/ \; || true
                  if [ -d "artifacts/Tauri Build Artifacts (macos-latest)/src-tauri/target/release/bundle/macos" ]; then
                    MACOS_BUNDLE_DIR="artifacts/Tauri Build Artifacts (macos-latest)/src-tauri/target/release/bundle/macos"
                    cd "$MACOS_BUNDLE_DIR"
                    shopt -s nullglob
                    apps=( *.app )
                    if [ ${#apps[@]} -gt 0 ]; then
                      for app in "${apps[@]}"; do
                        zip -r "$GITHUB_WORKSPACE/release-assets/${app%.app}.zip" "$app"
                      done
                    fi
                    cd -
                  fi

                  echo "Prepared release assets:"
                  ls -l release-assets/

            - name: Install GitHub CLI
              run: |
                  type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
                  curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
                  && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
                  && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
                  && sudo apt update \
                  && sudo apt install gh -y

            - name: Create GitHub Release
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  set -euo pipefail

                  NEW_VERSION="${{ needs.version.outputs.new_version }}"
                  echo "Creating release: $NEW_VERSION"

                  CHANGELOG_NOTES_FILE="RELEASE_NOTES.md"
                  cat <<'EOF' > "$CHANGELOG_NOTES_FILE"
                  ${{ needs.version.outputs.changelog }}
                  EOF

                  if ! gh release create "$NEW_VERSION" \
                    --title "CircuitVerse Desktop $NEW_VERSION" \
                    --notes-file "$CHANGELOG_NOTES_FILE" \
                    --latest \
                    release-assets/*; then
                    echo "Failed to create GitHub release"
                    exit 1
                  fi

                  echo "GitHub release created successfully"
                  echo "Release URL: https://github.com/${{ github.repository }}/releases/tag/$NEW_VERSION"

    security-validation:
        name: Security Validation
        runs-on: ubuntu-latest
        needs: [version, build-tauri, create-release]
        if: always() && needs.create-release.result == 'success'

        steps:
            - name: Checkout Repository
              uses: actions/checkout@v4

            - name: Download Release Artifacts
              run: |
                  NEW_VERSION="${{ needs.version.outputs.new_version }}"
                  gh release download "$NEW_VERSION" --dir artifacts
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

            - name: Validate Artifact Integrity
              run: |
                  echo "Validating release artifacts..."

                  for artifact in artifacts/*; do
                    if [ -f "$artifact" ]; then
                      size=$(stat -c%s "$artifact")
                      if [ "$size" -lt 1000 ]; then
                        echo "Artifact $artifact is too small ($size bytes)"
                        exit 1
                      fi
                      echo "$artifact ($size bytes)"
                    fi
                  done

            - name: Run Security Scans
              run: |
                  echo "Running security validation..."

                  cargo install cargo-audit
                  npm install -g audit-ci

                  cd src-tauri
                  cargo audit --quiet
                  cd ..

                  audit-ci --moderate

                  echo "Security validation completed"

            - name: Generate SBOM (Software Bill of Materials)
              run: |
                  echo "Generating SBOM..."

                  cargo install cargo-cyclonedx

                  cd src-tauri
                  cargo cyclonedx --output-format json --output-file ../sbom-rust.json
                  cd ..

                  npx @cyclonedx/cdxgen --type node -o sbom-npm.json .

                  NEW_VERSION="${{ needs.version.outputs.new_version }}"
                  gh release upload "$NEW_VERSION" sbom-rust.json sbom-npm.json
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

            - name: Post-Release Validation
              run: |
                  echo "Post-release validation completed"
                  echo "Release Summary:"
                  echo "  - Version: ${{ needs.version.outputs.new_version }}"
                  echo "  - Artifacts: $(find artifacts -type f | wc -l) files"
                  echo "  - Total Size: $(du -sh artifacts | cut -f1)"
                  echo "  - Security: Passed"
                  echo "  - SBOM: Generated"
